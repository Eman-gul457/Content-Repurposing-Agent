from __future__ import annotations

import html
import random
from datetime import datetime
from pathlib import Path
from urllib.parse import quote

import requests
from sqlalchemy.orm import Session

from backend.db_models import ContentPlan
from config.settings import settings

DEFAULT_IMAGE_SIZE = (1080, 1080)
PLAN_IMAGE_EXPIRES_SECONDS = 60 * 60 * 24 * 30


def _supabase_headers(content_type: str | None = None) -> dict[str, str]:
    if not settings.supabase_url or not settings.supabase_service_role_key:
        raise RuntimeError("SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY are required")
    headers = {
        "Authorization": f"Bearer {settings.supabase_service_role_key}",
        "apikey": settings.supabase_service_role_key,
    }
    if content_type:
        headers["Content-Type"] = content_type
    return headers


def _ensure_bucket() -> None:
    bucket = settings.supabase_storage_bucket
    url = f"{settings.supabase_url}/storage/v1/bucket/{bucket}"
    r = requests.get(url, headers=_supabase_headers(), timeout=30)
    if r.status_code == 200:
        return
    create = requests.post(
        f"{settings.supabase_url}/storage/v1/bucket",
        headers=_supabase_headers("application/json"),
        json={"id": bucket, "name": bucket, "public": False},
        timeout=30,
    )
    if create.status_code not in (200, 201, 409):
        raise RuntimeError(f"Failed to create storage bucket: {create.status_code} {create.text[:200]}")


def _generate_signed_url(storage_path: str, expires_in: int = PLAN_IMAGE_EXPIRES_SECONDS) -> str:
    bucket = settings.supabase_storage_bucket
    sign = requests.post(
        f"{settings.supabase_url}/storage/v1/object/sign/{bucket}/{storage_path}",
        headers=_supabase_headers("application/json"),
        json={"expiresIn": expires_in},
        timeout=30,
    )
    sign.raise_for_status()
    signed = sign.json().get("signedURL", "")
    if not signed:
        return ""
    return f"{settings.supabase_url}/storage/v1{signed}"


def _download_pollinations(prompt: str, width: int, height: int) -> tuple[bytes, str] | None:
    safe_prompt = quote(prompt[:400], safe="")
    seed = random.randint(1, 999999)
    urls = [
        f"https://image.pollinations.ai/prompt/{safe_prompt}?width={width}&height={height}&seed={seed}&model=flux&nologo=true",
        f"https://image.pollinations.ai/prompt/{safe_prompt}?width={width}&height={height}&seed={seed}&nologo=true",
    ]
    headers = {"User-Agent": "ContentRepurposingAgent/1.0"}
    for url in urls:
        try:
            response = requests.get(url, headers=headers, timeout=45)
        except Exception:
            continue
        ctype = (response.headers.get("content-type") or "").split(";")[0].strip().lower()
        if response.status_code == 200 and ctype.startswith("image/"):
            return response.content, ctype
    return None


def _fallback_post_svg(platform: str, theme: str, angle: str, business_name: str) -> bytes:
    title = html.escape((theme or f"{platform.upper()} campaign")[:64])
    subtitle = html.escape((angle or "AI-generated creative concept")[:120])
    brand = html.escape((business_name or "Your Brand")[:48])
    platform_label = html.escape(platform.upper())
    svg = f"""<svg xmlns="http://www.w3.org/2000/svg" width="1080" height="1080" viewBox="0 0 1080 1080">
  <defs>
    <linearGradient id="bg" x1="0" y1="0" x2="1" y2="1">
      <stop offset="0%" stop-color="#0b1320"/>
      <stop offset="100%" stop-color="#142c45"/>
    </linearGradient>
    <linearGradient id="tag" x1="0" y1="0" x2="1" y2="0">
      <stop offset="0%" stop-color="#11b58d"/>
      <stop offset="100%" stop-color="#2f80ff"/>
    </linearGradient>
  </defs>
  <rect width="1080" height="1080" fill="url(#bg)"/>
  <rect x="72" y="70" width="310" height="52" rx="14" fill="url(#tag)"/>
  <text x="95" y="104" font-family="Arial, sans-serif" font-size="30" fill="#ffffff">{platform_label} POST</text>
  <text x="72" y="210" font-family="Arial, sans-serif" font-weight="700" font-size="62" fill="#ecf3ff">{title}</text>
  <text x="72" y="312" font-family="Arial, sans-serif" font-size="36" fill="#9db0cf">{subtitle}</text>
  <rect x="72" y="860" width="936" height="2" fill="#2f4361"/>
  <text x="72" y="930" font-family="Arial, sans-serif" font-size="34" fill="#8ff4d7">{brand}</text>
  <text x="72" y="978" font-family="Arial, sans-serif" font-size="22" fill="#9db0cf">Generated by AI Content SaaS</text>
</svg>"""
    return svg.encode("utf-8")


def _mime_to_ext(mime_type: str) -> str:
    return {
        "image/png": "png",
        "image/jpeg": "jpg",
        "image/webp": "webp",
        "image/svg+xml": "svg",
    }.get(mime_type, "bin")


def generate_plan_image(db: Session, user_id: str, plan_id: int, business_name: str = "") -> ContentPlan:
    plan = db.query(ContentPlan).filter(ContentPlan.id == plan_id, ContentPlan.user_id == user_id).first()
    if not plan:
        raise RuntimeError("Plan not found")

    prompt = (plan.image_prompt or f"Social media creative for {plan.platform} {plan.theme}").strip()
    width, height = DEFAULT_IMAGE_SIZE
    image_bytes = b""
    mime_type = ""

    pol = _download_pollinations(prompt, width, height)
    if pol:
        image_bytes, mime_type = pol
    else:
        image_bytes = _fallback_post_svg(plan.platform, plan.theme, plan.post_angle, business_name)
        mime_type = "image/svg+xml"

    _ensure_bucket()
    ext = _mime_to_ext(mime_type)
    file_name = f"plan_{plan.id}_{int(datetime.utcnow().timestamp())}.{ext}"
    storage_path = str(Path(user_id) / "plans" / str(plan.id) / file_name).replace("\\", "/")

    upload = requests.post(
        f"{settings.supabase_url}/storage/v1/object/{settings.supabase_storage_bucket}/{storage_path}",
        headers={**_supabase_headers(mime_type), "x-upsert": "true"},
        data=image_bytes,
        timeout=60,
    )
    if upload.status_code not in (200, 201):
        raise RuntimeError(f"Plan image upload failed: {upload.status_code} {upload.text[:200]}")

    plan.image_url = _generate_signed_url(storage_path)
    plan.updated_at = datetime.utcnow()
    db.commit()
    db.refresh(plan)
    return plan
